<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Aleda" />
        <meta name="copyright" content="Aleda" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="code-reading, experience, code-reading, " />

<meta property="og:title" content="goquery and cascadia "/>
<meta property="og:url" content="http://aleda.cn/article/2015/12/goquery/" />
<meta property="og:description" content="goquery" />
<meta property="og:site_name" content="Aleda | Make Different" />
<meta property="og:article:author" content="Aleda" />
<meta property="og:article:published_time" content="2015-12-29T14:39:00+08:00" />
<meta name="twitter:title" content="goquery and cascadia ">
<meta name="twitter:description" content="goquery">

        <title>goquery and cascadia  · Aleda | Make Different
</title>
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="http://aleda.cn/theme/css/pygments.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://aleda.cn/theme/tipuesearch/tipuesearch.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://aleda.cn/theme/css/elegant.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://aleda.cn/theme/css/custom.css" media="screen">
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="http://aleda.cn/"><span class=site-name><span style="color:black;">Aleda</span> |  <span style="color:#AA1032;"> Make Different </span></span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="http://aleda.cn">Home</a></li>
                            <li ><a href="http://aleda.cn/categories.html">Categories</a></li>
                            <li ><a href="http://aleda.cn/tags.html">Tags</a></li>
                            <li ><a href="http://aleda.cn/archives.html">Archives</a></li>
                            <li><form class="navbar-search" action="http://aleda.cn/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page-header span10 offset2">
    <h1><a href="http://aleda.cn/article/2015/12/goquery/"> goquery and cascadia  </a></h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">

            
            <h1>goquery and cascadia</h1>
<h2><strong>Table of Contents</strong></h2>
<ul>
<li><a href="#1"><strong>1 goquery</strong></a>    <ul>
<li><a href="#1.1"><strong>1.1 Introduction</strong></a>    </li>
<li><a href="#1.2"><strong>1.2 Feature</strong></a>   </li>
<li><a href="#1.3"><strong>1.3 Code Analysis</strong></a><ul>
<li><a href="#1.3.1"><strong>1.3.1 type.go</strong></a></li>
<li><a href="#1.3.2"><strong>1.3.2 webapi.py</strong></a></li>
<li><a href="#1.3.3"><strong>1.3.3 application.py</strong></a></li>
<li><a href="#1.3.4"><strong>1.3.4 wsgiserver</strong></a></li>
<li><a href="#1.3.5"><strong>1.3.5 net.py</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><strong>1 goquery</strong></h2>
<h3><strong>1.1 Introduction</strong><span id="1.1"></span></h3>
<p><a href="https://github.com/PuerkitoBio/goquery">goquery</a> </p>
<h3><strong>1.2 Feature</strong><span id="1.2"></span></h3>
<p>goquery支持类似<a href="https://jquery.com/">jquery</a>的traversal的语法，作为Html的分析，解析的lib非常的简洁易用。</p>
<h3><strong>1.3 Code Analysis</strong><span id="1.3"></span></h3>
<h4><strong>1.3.1 type.go &amp; type_test.go</strong><span id="1.3.1"></span></h4>
<p>type.go这里定义了goquery的基本数据结构和接口，分别是：   </p>
<ol>
<li><strong>Document</strong>: </li>
</ol>
<p>// Document represents an HTML document to be manipulated. Unlike jQuery, which <br />
// is loaded as part of a DOM document, and thus acts upon its containing <br />
// document, GoQuery doesn't know which HTML document to act upon. So it needs <br />
// to be told, and that's what the Document class is for. It holds the root <br />
// document node to manipulate, and can make selections on this document.   </p>
<div class="highlight"><pre><span class="err">@</span><span class="o">|</span><span class="err">▼</span><span class="o">+</span><span class="nx">Document</span> <span class="o">:</span> <span class="nx">struct</span>
<span class="err">@</span><span class="o">|</span>    <span class="cp">[</span><span class="nx">fields</span><span class="cp">]</span>                                                                    
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">Url</span> <span class="o">:</span> <span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span>                                                              
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">rootNode</span> <span class="o">:</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span>
<span class="err">@</span><span class="o">|</span>    <span class="cp">[</span><span class="nx">embedded</span><span class="cp">]</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-*</span><span class="nx">Selection</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>    <span class="cp">[</span><span class="nx">functions</span><span class="cp">]</span>                                                                                                          
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">CloneDocument</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">Document</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Document</span>  <span class="c1">// deep-clone                                 </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NewDocument</span><span class="p">(</span><span class="nx">url</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Document</span><span class="p">,</span> <span class="nx">error</span> <span class="c1">// http.Get(url) and NewDocumentFromResponse</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NewDocumentFromNode</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Document</span> 
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NewDocumentFromReader</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Document</span><span class="p">,</span> <span class="nx">error</span>                       
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NewDocumentFromResponse</span><span class="p">(</span><span class="nx">res</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Response</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Document</span><span class="p">,</span> <span class="nx">error</span>              
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">newDocument</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">url</span> <span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Document</span>
</pre></div>


<ol>
<li><strong>Selection</strong>:</li>
</ol>
<p>// Selection represents a collection of nodes matching some criteria. The <br />
// initial Selection can be created by using Document.Find, and then <br />
// manipulated using the jQuery-like chainable syntax and methods.   </p>
<div class="highlight"><pre><span class="err">@</span><span class="o">|</span><span class="err">▼</span><span class="o">+</span><span class="nx">Selection</span> <span class="o">:</span> <span class="nx">struct</span>                                                                                                     
<span class="err">@</span><span class="o">|</span>    <span class="cp">[</span><span class="nx">fields</span><span class="cp">]</span>                                                                                                             
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">Nodes</span> <span class="o">:</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span>                                                                                                 
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nb">document</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Document</span>                                                                                                 
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">prevSel</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>    <span class="cp">[</span><span class="nx">functions</span><span class="cp">]</span>                                                                                                          
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">newEmptySelection</span><span class="p">(</span><span class="nx">doc</span> <span class="o">*</span><span class="nx">Document</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                        
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">newSingleSelection</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">doc</span> <span class="o">*</span><span class="nx">Document</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
</pre></div>


<ol>
<li><strong>Matcher</strong>:</li>
</ol>
<p>// Matcher is an interface that defines the methods to match <br />
// HTML nodes against a compiled selector string. Cascadia's <br />
// Selector implements this interface.   </p>
<div class="highlight"><pre>@|▼+Matcher : interface                                                                                                    
@|    [methods]                                                                                                            
@|   +Filter([]*html.Node) : []*html.Node                                                                                  
@|   +Match(*html.Node) : bool                                                                                             
@|   +MatchAll(*html.Node) : []*html.Node
</pre></div>


<h4><strong>1.3.2 array.go &amp; array_test.go</strong><span id="1.3.2"></span></h4>
<p>array.go 主要对selection中的具体的的Selector/Node获取(获取选择器或者Node)的一些方法的实现。</p>
<div class="highlight"><pre>@|▼ Selection* : ctype
@|    [methods]
@|   +Eq(index int) : *Selection // 获取id=index的Node，        
@|   +First() : *Selection 
@|   +Get(index int) : *html.Node                                                                                                   
@|   +Index() : int
@|   +IndexMatcher(m Matcher) : int                                                                                                 
@|   +IndexOfNode(node *html.Node) : int                                                                                            
@|   +IndexOfSelection(sel *Selection) : int                                                                                        
@|   +IndexSelector(selector string) : int                                                                                          
@|   +Last() : *Selection
@|   +Slice(start, end int) : *Selection
</pre></div>


<h4><strong>1.3.3 iteration.go &amp; iteration_test.go</strong><span id="1.3.3"></span></h4>
<p>iteration.go提供了三种对Selection遍历的方法：
简单&amp;容易理解，<strong>注意函数签名传到用户handler里面去的是当前遍历到的对Node包装好的Node</strong>。  </p>
<div class="highlight"><pre><span class="c1">// 遍历该Selection下面的所有Nodes，对每一个Node调用该函数签名func(int, *Selection)，</span>
<span class="c1">//其中int为Node的id。</span>
<span class="c1">// Each iterates over a Selection object, executing a function for each</span>
<span class="c1">// matched element. It returns the current Selection object.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Each</span><span class="p">(</span><span class="nx">f</span> <span class="nx">func</span><span class="p">(</span><span class="kr">int</span><span class="p">,</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">))</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">newSingleSelection</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nb">document</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="c1">// 遍历Selection下面的所有Nodes，但当用户返回非true返回值时，停止遍历。</span>
<span class="c1">// 必须实现的遍历函数签名为：func(int, *Selection) bool</span>
<span class="c1">// EachWithBreak iterates over a Selection object, executing a function for each</span>
<span class="c1">// matched element. It is identical to Each except that it is possible to break</span>
<span class="c1">// out of the loop by returning false in the callback function. It returns the</span>
<span class="c1">// current Selection object.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">EachWithBreak</span><span class="p">(</span><span class="nx">f</span> <span class="nx">func</span><span class="p">(</span><span class="kr">int</span><span class="p">,</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nx">f</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">newSingleSelection</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nb">document</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">s</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="c1">// 遍历Selection下面的所有Nodes，但存储处理每个Node的显式返回值，类型为String。</span>
<span class="c1">// 必须实现的遍历函数签名为：func(int, *Selection) string</span>
<span class="c1">// Map passes each element in the current matched set through a function,</span>
<span class="c1">// producing a slice of string holding the returned values.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">f</span> <span class="nx">func</span><span class="p">(</span><span class="kr">int</span><span class="p">,</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="cp">[]</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span> <span class="p">{</span>
        <span class="nx">result</span> <span class="o">=</span> <span class="nx">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">newSingleSelection</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nb">document</span><span class="p">)))</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>


<h4><strong>1.3.4 property.go &amp; property_test.go</strong><span id="1.3.4"></span></h4>
<p>property.go 主要提供对抽象的Slection（HTML DOM树）属性提取的方法。   </p>
<div class="highlight"><pre><span class="c1">// 返回该Selection的第一个Node的attrName对应的属性，这里一般结合Each等iterator函数共同使用；</span>
<span class="c1">// 上面说明了，Each的handler传递的Selection就是当前遍历到的Node的Wrapper。  </span>
<span class="c1">// Attr gets the specified attribute&#39;s value for the first element in the</span>
<span class="c1">// Selection. To get the value for each element individually, use a looping</span>
<span class="c1">// construct such as Each or Map method.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Attr</span><span class="p">(</span><span class="nx">attrName</span> <span class="nx">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">val</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">exists</span> <span class="nx">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">getAttributeValue</span><span class="p">(</span><span class="nx">attrName</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 不存在该Attr的时候，返回默认孩子defaultValue。  </span>
<span class="c1">// AttrOr works like Attr but returns default value if attribute is not present.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">AttrOr</span><span class="p">(</span><span class="nx">attrName</span><span class="p">,</span> <span class="nx">defaultValue</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">defaultValue</span>
    <span class="p">}</span>

    <span class="nx">val</span><span class="p">,</span> <span class="nx">exists</span> <span class="o">:=</span> <span class="nx">getAttributeValue</span><span class="p">(</span><span class="nx">attrName</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="p">)</span>
    <span class="k">if</span> <span class="o">!</span><span class="nx">exists</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">defaultValue</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">val</span>
<span class="p">}</span>

<span class="c1">//  遍历所有的Node，删除对应的attrName的属性。</span>
<span class="c1">// RemoveAttr removes the named attribute from each element in the set of matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">RemoveAttr</span><span class="p">(</span><span class="nx">attrName</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span> <span class="p">{</span>
        <span class="nx">removeAttr</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">attrName</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="c1">// 遍历Selection的所有Node，对attrName赋值val</span>
<span class="c1">// SetAttr sets the given attribute on each element in the set of matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">SetAttr</span><span class="p">(</span><span class="nx">attrName</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span> <span class="p">{</span>
        <span class="nx">attr</span> <span class="o">:=</span> <span class="nx">getAttributePtr</span><span class="p">(</span><span class="nx">attrName</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">attr</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
            <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="o">=</span> <span class="nx">append</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span><span class="p">,</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Attribute</span><span class="p">{</span><span class="nx">Key</span><span class="o">:</span> <span class="nx">attrName</span><span class="p">,</span> <span class="nx">Val</span><span class="o">:</span> <span class="nx">val</span><span class="p">})</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">attr</span><span class="p">.</span><span class="nx">Val</span> <span class="o">=</span> <span class="nx">val</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="c1">// 遍历所有的Node，取出每个Node的Text。</span>
<span class="c1">// Text gets the combined text contents of each element in the set of matched</span>
<span class="c1">// elements, including their descendants.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Text</span><span class="p">()</span> <span class="nx">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="c1">// 比Each遍历的小小优化：不用创建那么多的Single Selection了</span>
    <span class="c1">// Slightly optimized vs calling Each: no single selection object created</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span> <span class="p">{</span>
        <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">getNodeText</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nb">String</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// 和length一样，返回Node的长度</span>
<span class="c1">// Size is an alias for Length.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Size</span><span class="p">()</span> <span class="kr">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Length</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// 返回Length的长度，不存在cap，用多少就申请多少（会出现多次）</span>
<span class="c1">// Length returns the number of elements in the Selection object.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Length</span><span class="p">()</span> <span class="kr">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 读取在Selection中的第一个Node的html。</span>
<span class="c1">// Html gets the HTML contents of the first element in the set of matched</span>
<span class="c1">// elements. It includes text and comment nodes.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Html</span><span class="p">()</span> <span class="p">(</span><span class="nx">ret</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">e</span> <span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Since there is no .innerHtml, the HTML content must be re-created from</span>
    <span class="c1">// the nodes using html.Render.</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>

    <span class="k">if</span> <span class="nx">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
            <span class="nx">e</span> <span class="o">=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Render</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
                <span class="k">return</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">ret</span> <span class="o">=</span> <span class="nx">buf</span><span class="p">.</span><span class="nb">String</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="c1">// 增加此Selection中对应的所有Node下的class属性，增加为class</span>
<span class="c1">// AddClass adds the given class(es) to each element in the set of matched elements.</span>
<span class="c1">// Multiple class names can be specified, separated by a space or via multiple arguments.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">AddClass</span><span class="p">(</span><span class="kr">class</span> <span class="p">...</span><span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="nx">classStr</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">TrimSpace</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="kr">class</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">))</span>

    <span class="k">if</span> <span class="nx">classStr</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">s</span>
    <span class="p">}</span>

    <span class="nx">tcls</span> <span class="o">:=</span> <span class="nx">getClassesSlice</span><span class="p">(</span><span class="nx">classStr</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span> <span class="p">{</span>
        <span class="nx">curClasses</span><span class="p">,</span> <span class="nx">attr</span> <span class="o">:=</span> <span class="nx">getClassesAndAttr</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">newClass</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">tcls</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">curClasses</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nx">newClass</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
                <span class="nx">curClasses</span> <span class="o">+=</span> <span class="nx">newClass</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">setClasses</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">attr</span><span class="p">,</span> <span class="nx">curClasses</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="c1">// 判断Selection下面的所有Node下面是否有class匹配class string</span>
<span class="c1">// HasClass determines whether any of the matched elements are assigned the</span>
<span class="c1">// given class.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">HasClass</span><span class="p">(</span><span class="kr">class</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
    <span class="kr">class</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="kr">class</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span> <span class="p">{</span>
        <span class="nx">classes</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">getClassesAndAttr</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">classes</span><span class="p">,</span> <span class="kr">class</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// Remove该Selection下的所有属性class中命名参数class的内容，参数中的class以空格分隔。</span>
<span class="c1">// RemoveClass removes the given class(es) from each element in the set of matched elements.</span>
<span class="c1">// Multiple class names can be specified, separated by a space or via multiple arguments.</span>
<span class="c1">// If no class name is provided, all classes are removed.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">RemoveClass</span><span class="p">(</span><span class="kr">class</span> <span class="p">...</span><span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">rclasses</span> <span class="cp">[]</span><span class="nx">string</span>

    <span class="nx">classStr</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">TrimSpace</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="kr">class</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">))</span>
    <span class="nx">remove</span> <span class="o">:=</span> <span class="nx">classStr</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>

    <span class="k">if</span> <span class="o">!</span><span class="nx">remove</span> <span class="p">{</span>
        <span class="nx">rclasses</span> <span class="o">=</span> <span class="nx">getClassesSlice</span><span class="p">(</span><span class="nx">classStr</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">remove</span> <span class="p">{</span>
            <span class="nx">removeAttr</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="s2">&quot;class&quot;</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">classes</span><span class="p">,</span> <span class="nx">attr</span> <span class="o">:=</span> <span class="nx">getClassesAndAttr</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
            <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">rcl</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">rclasses</span> <span class="p">{</span>
                <span class="nx">classes</span> <span class="o">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Replace</span><span class="p">(</span><span class="nx">classes</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nx">rcl</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="nx">setClasses</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">attr</span><span class="p">,</span> <span class="nx">classes</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="c1">// ToggleClass adds or removes the given class(es) for each element in the set of matched elements.</span>
<span class="c1">// Multiple class names can be specified, separated by a space or via multiple arguments.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ToggleClass</span><span class="p">(</span><span class="kr">class</span> <span class="p">...</span><span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="nx">classStr</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">TrimSpace</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="kr">class</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">))</span>

    <span class="k">if</span> <span class="nx">classStr</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">s</span>
    <span class="p">}</span>

    <span class="nx">tcls</span> <span class="o">:=</span> <span class="nx">getClassesSlice</span><span class="p">(</span><span class="nx">classStr</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span> <span class="p">{</span>
        <span class="nx">classes</span><span class="p">,</span> <span class="nx">attr</span> <span class="o">:=</span> <span class="nx">getClassesAndAttr</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tcl</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">tcls</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">classes</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nx">tcl</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
                <span class="nx">classes</span> <span class="o">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Replace</span><span class="p">(</span><span class="nx">classes</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nx">tcl</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">classes</span> <span class="o">+=</span> <span class="nx">tcl</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">setClasses</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">attr</span><span class="p">,</span> <span class="nx">classes</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="c1">// Get the specified node&#39;s text content.</span>
<span class="nx">func</span> <span class="nx">getNodeText</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">TextNode</span> <span class="p">{</span>
        <span class="c1">// Keep newlines and spaces, like jQuery</span>
        <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Data</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">FirstChild</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">buf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
        <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
            <span class="nx">buf</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">getNodeText</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nb">String</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span>
<span class="p">}</span>

<span class="nx">func</span> <span class="nx">getAttributePtr</span><span class="p">(</span><span class="nx">attrName</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Attribute</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">nil</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span> <span class="o">==</span> <span class="nx">attrName</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span><span class="cp">[</span><span class="nx">i</span><span class="cp">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">nil</span>
<span class="p">}</span>

<span class="c1">// Private function to get the specified attribute&#39;s value from a node.</span>
<span class="nx">func</span> <span class="nx">getAttributeValue</span><span class="p">(</span><span class="nx">attrName</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">val</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">exists</span> <span class="nx">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">a</span> <span class="o">:=</span> <span class="nx">getAttributePtr</span><span class="p">(</span><span class="nx">attrName</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span> <span class="nx">a</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="nx">val</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Val</span>
        <span class="nx">exists</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Get and normalize the &quot;class&quot; attribute from the node.</span>
<span class="nx">func</span> <span class="nx">getClassesAndAttr</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">create</span> <span class="nx">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">classes</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">attr</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Attribute</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Applies only to element nodes</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
        <span class="nx">attr</span> <span class="o">=</span> <span class="nx">getAttributePtr</span><span class="p">(</span><span class="s2">&quot;class&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">attr</span> <span class="o">==</span> <span class="nx">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">create</span> <span class="p">{</span>
            <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="o">=</span> <span class="nx">append</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span><span class="p">,</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Attribute</span><span class="p">{</span>
                <span class="nx">Key</span><span class="o">:</span> <span class="s2">&quot;class&quot;</span><span class="p">,</span>
                <span class="nx">Val</span><span class="o">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="p">})</span>
            <span class="nx">attr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span><span class="cp">[</span><span class="nx">len</span><span class="p">(</span><span class="nx">n.Attr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="cp">]</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">attr</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="nx">classes</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">classes</span> <span class="o">=</span> <span class="nx">rxClassTrim</span><span class="p">.</span><span class="nx">ReplaceAllString</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nx">attr</span><span class="p">.</span><span class="nx">Val</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span>
<span class="p">}</span>

<span class="nx">func</span> <span class="nx">getClassesSlice</span><span class="p">(</span><span class="nx">classes</span> <span class="nx">string</span><span class="p">)</span> <span class="cp">[]</span><span class="nx">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Split</span><span class="p">(</span><span class="nx">rxClassTrim</span><span class="p">.</span><span class="nx">ReplaceAllString</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="nx">classes</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">),</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 遍历Node的所有属性（属性之间无序），找到要remove的属性，将属性的最后一个属性Map插入到这里；</span>
<span class="c1">// 这里其实是要注意，加入只有一个属性的时候的问题处理，不过作者写的非常的棒，利用Slice的特点和赋值操作是从左</span>
<span class="c1">// 向右依次赋值，一句话解决。</span>
<span class="nx">func</span> <span class="nx">removeAttr</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">attrName</span> <span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span> <span class="o">==</span> <span class="nx">attrName</span> <span class="p">{</span>
            <span class="c1">// Great！！~~~</span>
            <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span><span class="cp">[</span><span class="nx">i</span><span class="cp">]</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span><span class="cp">[</span><span class="nx">len</span><span class="p">(</span><span class="nx">n.Attr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="cp">]</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="o">=</span>
                <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span><span class="cp">[</span><span class="nx">len</span><span class="p">(</span><span class="nx">n.Attr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="cp">]</span><span class="p">,</span> <span class="nx">html</span><span class="p">.</span><span class="nx">Attribute</span><span class="p">{},</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span><span class="cp">[</span><span class="p">:</span><span class="nx">len</span><span class="p">(</span><span class="nx">n.Attr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="cp">]</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">func</span> <span class="nx">setClasses</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">attr</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Attribute</span><span class="p">,</span> <span class="nx">classes</span> <span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">classes</span> <span class="o">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">TrimSpace</span><span class="p">(</span><span class="nx">classes</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">classes</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="p">{</span>
        <span class="nx">removeAttr</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="s2">&quot;class&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="nx">attr</span><span class="p">.</span><span class="nx">Val</span> <span class="o">=</span> <span class="nx">classes</span>
<span class="p">}</span>
</pre></div>


<h4><strong>1.3.5 utilities.go </strong><span id="1.3.5"></span></h4>
<p>一些公用方法，包括：</p>
<div class="highlight"><pre><span class="err">▼</span> <span class="nx">functions</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">getChildren</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="c1">//获取该Node下的所有childrenNode</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">sliceContains</span><span class="p">(</span><span class="nx">container</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">contained</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="nx">bool</span> <span class="c1">// </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">nodeContains</span><span class="p">(</span><span class="nx">container</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">contained</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="nx">bool</span> <span class="c1">//遍历container并判断The contained Node是否包含(同层级不算包含)在其中任何一个Node中   </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">isInSlice</span><span class="p">(</span><span class="nx">slice</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">node</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="nx">bool</span> <span class="c1">// 判断node是否在node slice中</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">indexInSlice</span><span class="p">(</span><span class="nx">slice</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">node</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="kr">int</span> <span class="c1">// 判断node所在slice中的位置                   </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">appendWithoutDuplicates</span><span class="p">(</span><span class="nx">target</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="c1">//去重append到target slice中 </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">grep</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">,</span> <span class="nx">predicate</span> <span class="nx">func</span><span class="p">(</span><span class="nx">i</span> <span class="kr">int</span><span class="p">,</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">bool</span><span class="p">)</span> <span class="o">:</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span>  <span class="c1">// 遍历selection的Node, 返回满足predicate的nodes   </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">pushStack</span><span class="p">(</span><span class="nx">fromSel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">,</span> <span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span> <span class="c1">// 把nodes加入到新的selection中，旧的作为prevSel。</span>
</pre></div>


<h4><strong>1.3.6 traversal.go </strong><span id="1.3.6"></span></h4>
<p>页面的所有traversal(遍历)API都在这里了，对这些API研究透了，基本上，goquery你就能利用的如鱼得水了。<br />
这里面方法设计的非常巧妙。代码也不长，并且有强大的注释，贴出来，共同研习。</p>
<div class="highlight"><pre><span class="err">@</span><span class="o">|</span><span class="err">▼</span> <span class="nx">constants</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">siblingPrevUntil</span> <span class="o">:</span> <span class="nx">siblingType</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">siblingPrevAll</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">siblingPrev</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">siblingAll</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">siblingNext</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">siblingNextAll</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">siblingNextUntil</span>                                                                                                     
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">siblingAllIncludingNonElements</span>
<span class="err">@</span><span class="o">|</span><span class="err">▼</span> <span class="nx">Selection</span><span class="o">*</span> <span class="o">:</span> <span class="nx">ctype</span>                                                                                                     
<span class="err">@</span><span class="o">|</span>    <span class="cp">[</span><span class="nx">methods</span><span class="cp">]</span>                                                                                                            
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">Find</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>  <span class="c1">// 最重要的API了，类似jquery的选择器$()，给出的selector string必须是有效的jquey语法，详情看下面的cscadia.MustCompile            </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">FindMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span> <span class="c1">// 筛选符合Matcher(见type.go的)的Selection。                                </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">FindSelection</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span> <span class="c1">// 找到该Selection，也就是匹配该selection下面的所有Nodes               </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">FindNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span> <span class="c1">// 匹配所有的nodes</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">Contents</span><span class="p">()</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span> <span class="c1">// </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ContentsFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span> <span class="c1">// </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ContentsMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">Children</span><span class="p">()</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                                              
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ChildrenFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ChildrenMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">Parent</span><span class="p">()</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span> 
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">Closest</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ClosestMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                               
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ClosestNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                                    
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ClosestSelection</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>  
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ClosestNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                                    
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ClosestSelection</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                        
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">Parents</span><span class="p">()</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                                               
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                        
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                               
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsUntil</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                           
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsUntilMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                          
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsUntilSelection</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                   
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsUntilNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                               
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsFilteredUntil</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">,</span> <span class="nx">untilSelector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                              
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsFilteredUntilMatcher</span><span class="p">(</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">until</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                      
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsFilteredUntilSelection</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                    
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsMatcherUntilSelection</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                            
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsFilteredUntilNodes</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">ParentsMatcherUntilNodes</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">Siblings</span><span class="p">()</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">SiblingsFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                       
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">SiblingsMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                              
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">Next</span><span class="p">()</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                                                  
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                           
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                                  
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextAll</span><span class="p">()</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>     
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextAllFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                        
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextAllMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                               
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">Prev</span><span class="p">()</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                                                  
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                           
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                                  
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevAll</span><span class="p">()</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                                               
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevAllFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                        
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevAllMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                               
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextUntil</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                              
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextUntilMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                             
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextUntilSelection</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                      
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextUntilNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevUntil</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevUntilMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                             
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevUntilSelection</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                      
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevUntilNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                                                  
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextFilteredUntil</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">,</span> <span class="nx">untilSelector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                 
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextFilteredUntilMatcher</span><span class="p">(</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">until</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                         
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextFilteredUntilSelection</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                       
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextMatcherUntilSelection</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span> 
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextMatcherUntilSelection</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextFilteredUntilNodes</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                   
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">NextMatcherUntilNodes</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                           
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevFilteredUntil</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">,</span> <span class="nx">untilSelector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                 
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevFilteredUntilMatcher</span><span class="p">(</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">until</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                         
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevFilteredUntilSelection</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                       
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevMatcherUntilSelection</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                               
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevFilteredUntilNodes</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                                   
<span class="err">@</span><span class="o">|</span>   <span class="o">+</span><span class="nx">PrevMatcherUntilNodes</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>  
<span class="err">@</span><span class="o">|</span><span class="err">▼</span> <span class="nx">functions</span>                                                                                                              
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">srcSel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">,</span> <span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="nx">Selection</span>                                         
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">findWithMatcher</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">:</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span>                                                        
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">stopm</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">stopNodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span>                            
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">siblingType</span><span class="p">,</span> <span class="nx">untilm</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">untilNodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span>          
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">getChildrenNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">siblingType</span><span class="p">)</span> <span class="o">:</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">getChildrenWithSiblingType</span><span class="p">(</span><span class="nx">parent</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">siblingType</span><span class="p">,</span> <span class="nx">skipNode</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">untilFunc</span> <span class="nx">func</span><span class="p">(</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span><span class="p">)</span> <span class="c1">// </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">getParentNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="c1">// 获得所有的parentsNode              </span>
<span class="err">@</span><span class="o">|</span>   <span class="o">-</span><span class="nx">mapNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">f</span> <span class="nx">func</span><span class="p">(</span><span class="kr">int</span><span class="p">,</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">:</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="c1">// 基础的共用map方法。</span>

<span class="c1">// Find gets the descendants of each element in the current set of matched</span>
<span class="c1">// elements, filtered by a selector. It returns a new Selection object</span>
<span class="c1">// containing these matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Find</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">findWithMatcher</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">)))</span>
<span class="p">}</span>

<span class="c1">// FindMatcher gets the descendants of each element in the current set of matched</span>
<span class="c1">// elements, filtered by the matcher. It returns a new Selection object</span>
<span class="c1">// containing these matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">FindMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">findWithMatcher</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">m</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// FindSelection gets the descendants of each element in the current</span>
<span class="c1">// Selection, filtered by a Selection. It returns a new Selection object</span>
<span class="c1">// containing these matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">FindSelection</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">sel</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">nil</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">FindNodes</span><span class="p">(</span><span class="nx">sel</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">...)</span>
<span class="p">}</span>

<span class="c1">// FindNodes gets the descendants of each element in the current</span>
<span class="c1">// Selection, filtered by some nodes. It returns a new Selection object</span>
<span class="c1">// containing these matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">FindNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">mapNodes</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">func</span><span class="p">(</span><span class="nx">i</span> <span class="kr">int</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">sliceContains</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">{</span><span class="nx">n</span><span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">nil</span>
    <span class="p">}))</span>
<span class="p">}</span>

<span class="c1">// Contents gets the children of each element in the Selection,</span>
<span class="c1">// including text and comment nodes. It returns a new Selection object</span>
<span class="c1">// containing these elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Contents</span><span class="p">()</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getChildrenNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingAllIncludingNonElements</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ContentsFiltered gets the children of each element in the Selection,</span>
<span class="c1">// filtered by the specified selector. It returns a new Selection</span>
<span class="c1">// object containing these elements. Since selectors only act on Element nodes,</span>
<span class="c1">// this function is an alias to ChildrenFiltered unless the selector is empty,</span>
<span class="c1">// in which case it is an alias to Contents.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ContentsFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">selector</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ChildrenFiltered</span><span class="p">(</span><span class="nx">selector</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Contents</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// ContentsMatcher gets the children of each element in the Selection,</span>
<span class="c1">// filtered by the specified matcher. It returns a new Selection</span>
<span class="c1">// object containing these elements. Since matchers only act on Element nodes,</span>
<span class="c1">// this function is an alias to ChildrenMatcher.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ContentsMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ChildrenMatcher</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Children gets the child elements of each element in the Selection.</span>
<span class="c1">// It returns a new Selection object containing these elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Children</span><span class="p">()</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getChildrenNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingAll</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ChildrenFiltered gets the child elements of each element in the Selection,</span>
<span class="c1">// filtered by the specified selector. It returns a new</span>
<span class="c1">// Selection object containing these elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ChildrenFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getChildrenNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingAll</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ChildrenMatcher gets the child elements of each element in the Selection,</span>
<span class="c1">// filtered by the specified matcher. It returns a new</span>
<span class="c1">// Selection object containing these elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ChildrenMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getChildrenNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingAll</span><span class="p">),</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Parent gets the parent of each element in the Selection. It returns a</span>
<span class="c1">// new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Parent</span><span class="p">()</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ParentFiltered gets the parent of each element in the Selection filtered by a</span>
<span class="c1">// selector. It returns a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ParentMatcher gets the parent of each element in the Selection filtered by a</span>
<span class="c1">// matcher. It returns a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">),</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Closest gets the first element that matches the selector by testing the</span>
<span class="c1">// element itself and traversing up through its ancestors in the DOM tree.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Closest</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="nx">cs</span> <span class="o">:=</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ClosestMatcher</span><span class="p">(</span><span class="nx">cs</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ClosestMatcher gets the first element that matches the matcher by testing the</span>
<span class="c1">// element itself and traversing up through its ancestors in the DOM tree.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ClosestMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">mapNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">func</span><span class="p">(</span><span class="nx">i</span> <span class="kr">int</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
        <span class="c1">// For each node in the selection, test the node itself, then each parent</span>
        <span class="c1">// until a match is found.</span>
        <span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Match</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">{</span><span class="nx">n</span><span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">nil</span>
    <span class="p">}))</span>
<span class="p">}</span>

<span class="c1">// ClosestNodes gets the first element that matches one of the nodes by testing the</span>
<span class="c1">// element itself and traversing up through its ancestors in the DOM tree.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ClosestNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">mapNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">func</span><span class="p">(</span><span class="nx">i</span> <span class="kr">int</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
        <span class="c1">// For each node in the selection, test the node itself, then each parent</span>
        <span class="c1">// until a match is found.</span>
        <span class="k">for</span> <span class="p">;</span> <span class="nx">n</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">isInSlice</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">{</span><span class="nx">n</span><span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">nil</span>
    <span class="p">}))</span>
<span class="p">}</span>

<span class="c1">// ClosestSelection gets the first element that matches one of the nodes in the</span>
<span class="c1">// Selection by testing the element itself and traversing up through its ancestors</span>
<span class="c1">// in the DOM tree.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ClosestSelection</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">sel</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">nil</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ClosestNodes</span><span class="p">(</span><span class="nx">sel</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">...)</span>
<span class="p">}</span>

<span class="c1">// Parents gets the ancestors of each element in the current Selection. It</span>
<span class="c1">// returns a new Selection object with the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Parents</span><span class="p">()</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ParentsFiltered gets the ancestors of each element in the current</span>
<span class="c1">// Selection. It returns a new Selection object with the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ParentsMatcher gets the ancestors of each element in the current</span>
<span class="c1">// Selection. It returns a new Selection object with the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ParentsUntil gets the ancestors of each element in the Selection, up to but</span>
<span class="c1">// not including the element matched by the selector. It returns a new Selection</span>
<span class="c1">// object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsUntil</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">),</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ParentsUntilMatcher gets the ancestors of each element in the Selection, up to but</span>
<span class="c1">// not including the element matched by the matcher. It returns a new Selection</span>
<span class="c1">// object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsUntilMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ParentsUntilSelection gets the ancestors of each element in the Selection,</span>
<span class="c1">// up to but not including the elements in the specified Selection. It returns a</span>
<span class="c1">// new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsUntilSelection</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">sel</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Parents</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ParentsUntilNodes</span><span class="p">(</span><span class="nx">sel</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">...)</span>
<span class="p">}</span>

<span class="c1">// ParentsUntilNodes gets the ancestors of each element in the Selection,</span>
<span class="c1">// up to but not including the specified nodes. It returns a</span>
<span class="c1">// new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsUntilNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ParentsFilteredUntil is like ParentsUntil, with the option to filter the</span>
<span class="c1">// results based on a selector string. It returns a new Selection</span>
<span class="c1">// object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsFilteredUntil</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">,</span> <span class="nx">untilSelector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">untilSelector</span><span class="p">),</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ParentsFilteredUntilMatcher is like ParentsUntilMatcher, with the option to filter the</span>
<span class="c1">// results based on a matcher. It returns a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsFilteredUntilMatcher</span><span class="p">(</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">until</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">until</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">filter</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ParentsFilteredUntilSelection is like ParentsUntilSelection, with the</span>
<span class="c1">// option to filter the results based on a selector string. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsFilteredUntilSelection</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ParentsMatcherUntilSelection</span><span class="p">(</span><span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">),</span> <span class="nx">sel</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ParentsMatcherUntilSelection is like ParentsUntilSelection, with the</span>
<span class="c1">// option to filter the results based on a matcher. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsMatcherUntilSelection</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">sel</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ParentsMatcher</span><span class="p">(</span><span class="nx">filter</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ParentsMatcherUntilNodes</span><span class="p">(</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">sel</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">...)</span>
<span class="p">}</span>

<span class="c1">// ParentsFilteredUntilNodes is like ParentsUntilNodes, with the</span>
<span class="c1">// option to filter the results based on a selector string. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsFilteredUntilNodes</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// ParentsMatcherUntilNodes is like ParentsUntilNodes, with the</span>
<span class="c1">// option to filter the results based on a matcher. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">ParentsMatcherUntilNodes</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">),</span> <span class="nx">filter</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Siblings gets the siblings of each element in the Selection. It returns</span>
<span class="c1">// a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Siblings</span><span class="p">()</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingAll</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// SiblingsFiltered gets the siblings of each element in the Selection</span>
<span class="c1">// filtered by a selector. It returns a new Selection object containing the</span>
<span class="c1">// matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">SiblingsFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingAll</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// SiblingsMatcher gets the siblings of each element in the Selection</span>
<span class="c1">// filtered by a matcher. It returns a new Selection object containing the</span>
<span class="c1">// matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">SiblingsMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingAll</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Next gets the immediately following sibling of each element in the</span>
<span class="c1">// Selection. It returns a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Next</span><span class="p">()</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNext</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// NextFiltered gets the immediately following sibling of each element in the</span>
<span class="c1">// Selection filtered by a selector. It returns a new Selection object</span>
<span class="c1">// containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNext</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// NextMatcher gets the immediately following sibling of each element in the</span>
<span class="c1">// Selection filtered by a matcher. It returns a new Selection object</span>
<span class="c1">// containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNext</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// NextAll gets all the following siblings of each element in the</span>
<span class="c1">// Selection. It returns a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextAll</span><span class="p">()</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNextAll</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// NextAllFiltered gets all the following siblings of each element in the</span>
<span class="c1">// Selection filtered by a selector. It returns a new Selection object</span>
<span class="c1">// containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextAllFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNextAll</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// NextAllMatcher gets all the following siblings of each element in the</span>
<span class="c1">// Selection filtered by a matcher. It returns a new Selection object</span>
<span class="c1">// containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextAllMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNextAll</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Prev gets the immediately preceding sibling of each element in the</span>
<span class="c1">// Selection. It returns a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">Prev</span><span class="p">()</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrev</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// PrevFiltered gets the immediately preceding sibling of each element in the</span>
<span class="c1">// Selection filtered by a selector. It returns a new Selection object</span>
<span class="c1">// containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrev</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// PrevMatcher gets the immediately preceding sibling of each element in the</span>
<span class="c1">// Selection filtered by a matcher. It returns a new Selection object</span>
<span class="c1">// containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrev</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// PrevAll gets all the preceding siblings of each element in the</span>
<span class="c1">// Selection. It returns a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevAll</span><span class="p">()</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrevAll</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// PrevAllFiltered gets all the preceding siblings of each element in the</span>
<span class="c1">// Selection filtered by a selector. It returns a new Selection object</span>
<span class="c1">// containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevAllFiltered</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrevAll</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// PrevAllMatcher gets all the preceding siblings of each element in the</span>
<span class="c1">// Selection filtered by a matcher. It returns a new Selection object</span>
<span class="c1">// containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevAllMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrevAll</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// NextUntil gets all following siblings of each element up to but not</span>
<span class="c1">// including the element matched by the selector. It returns a new Selection</span>
<span class="c1">// object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextUntil</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNextUntil</span><span class="p">,</span>
        <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">),</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// NextUntilMatcher gets all following siblings of each element up to but not</span>
<span class="c1">// including the element matched by the matcher. It returns a new Selection</span>
<span class="c1">// object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextUntilMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNextUntil</span><span class="p">,</span>
        <span class="nx">m</span><span class="p">,</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// NextUntilSelection gets all following siblings of each element up to but not</span>
<span class="c1">// including the element matched by the Selection. It returns a new Selection</span>
<span class="c1">// object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextUntilSelection</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">sel</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">NextAll</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">NextUntilNodes</span><span class="p">(</span><span class="nx">sel</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">...)</span>
<span class="p">}</span>

<span class="c1">// NextUntilNodes gets all following siblings of each element up to but not</span>
<span class="c1">// including the element matched by the nodes. It returns a new Selection</span>
<span class="c1">// object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextUntilNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNextUntil</span><span class="p">,</span>
        <span class="nx">nil</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// PrevUntil gets all preceding siblings of each element up to but not</span>
<span class="c1">// including the element matched by the selector. It returns a new Selection</span>
<span class="c1">// object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevUntil</span><span class="p">(</span><span class="nx">selector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrevUntil</span><span class="p">,</span>
        <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">selector</span><span class="p">),</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// PrevUntilMatcher gets all preceding siblings of each element up to but not</span>
<span class="c1">// including the element matched by the matcher. It returns a new Selection</span>
<span class="c1">// object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevUntilMatcher</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrevUntil</span><span class="p">,</span>
        <span class="nx">m</span><span class="p">,</span> <span class="nx">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// PrevUntilSelection gets all preceding siblings of each element up to but not</span>
<span class="c1">// including the element matched by the Selection. It returns a new Selection</span>
<span class="c1">// object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevUntilSelection</span><span class="p">(</span><span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">sel</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">PrevAll</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">PrevUntilNodes</span><span class="p">(</span><span class="nx">sel</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">...)</span>
<span class="p">}</span>

<span class="c1">// PrevUntilNodes gets all preceding siblings of each element up to but not</span>
<span class="c1">// including the element matched by the nodes. It returns a new Selection</span>
<span class="c1">// object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevUntilNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrevUntil</span><span class="p">,</span>
        <span class="nx">nil</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// NextFilteredUntil is like NextUntil, with the option to filter</span>
<span class="c1">// the results based on a selector string.</span>
<span class="c1">// It returns a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextFilteredUntil</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">,</span> <span class="nx">untilSelector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNextUntil</span><span class="p">,</span>
        <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">untilSelector</span><span class="p">),</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// NextFilteredUntilMatcher is like NextUntilMatcher, with the option to filter</span>
<span class="c1">// the results based on a matcher.</span>
<span class="c1">// It returns a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextFilteredUntilMatcher</span><span class="p">(</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">until</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNextUntil</span><span class="p">,</span>
        <span class="nx">until</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">filter</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// NextFilteredUntilSelection is like NextUntilSelection, with the</span>
<span class="c1">// option to filter the results based on a selector string. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextFilteredUntilSelection</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">NextMatcherUntilSelection</span><span class="p">(</span><span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">),</span> <span class="nx">sel</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// NextMatcherUntilSelection is like NextUntilSelection, with the</span>
<span class="c1">// option to filter the results based on a matcher. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextMatcherUntilSelection</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">sel</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">NextMatcher</span><span class="p">(</span><span class="nx">filter</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">NextMatcherUntilNodes</span><span class="p">(</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">sel</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">...)</span>
<span class="p">}</span>

<span class="c1">// NextFilteredUntilNodes is like NextUntilNodes, with the</span>
<span class="c1">// option to filter the results based on a selector string. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextFilteredUntilNodes</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNextUntil</span><span class="p">,</span>
        <span class="nx">nil</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// NextMatcherUntilNodes is like NextUntilNodes, with the</span>
<span class="c1">// option to filter the results based on a matcher. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">NextMatcherUntilNodes</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingNextUntil</span><span class="p">,</span>
        <span class="nx">nil</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">),</span> <span class="nx">filter</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// PrevFilteredUntil is like PrevUntil, with the option to filter</span>
<span class="c1">// the results based on a selector string.</span>
<span class="c1">// It returns a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevFilteredUntil</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">,</span> <span class="nx">untilSelector</span> <span class="nx">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrevUntil</span><span class="p">,</span>
        <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">untilSelector</span><span class="p">),</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// PrevFilteredUntilMatcher is like PrevUntilMatcher, with the option to filter</span>
<span class="c1">// the results based on a matcher.</span>
<span class="c1">// It returns a new Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevFilteredUntilMatcher</span><span class="p">(</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">until</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrevUntil</span><span class="p">,</span>
        <span class="nx">until</span><span class="p">,</span> <span class="nx">nil</span><span class="p">),</span> <span class="nx">filter</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// PrevFilteredUntilSelection is like PrevUntilSelection, with the</span>
<span class="c1">// option to filter the results based on a selector string. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevFilteredUntilSelection</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">PrevMatcherUntilSelection</span><span class="p">(</span><span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">),</span> <span class="nx">sel</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// PrevMatcherUntilSelection is like PrevUntilSelection, with the</span>
<span class="c1">// option to filter the results based on a matcher. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevMatcherUntilSelection</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">sel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">sel</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">PrevMatcher</span><span class="p">(</span><span class="nx">filter</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">PrevMatcherUntilNodes</span><span class="p">(</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">sel</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">...)</span>
<span class="p">}</span>

<span class="c1">// PrevFilteredUntilNodes is like PrevUntilNodes, with the</span>
<span class="c1">// option to filter the results based on a selector string. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevFilteredUntilNodes</span><span class="p">(</span><span class="nx">filterSelector</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrevUntil</span><span class="p">,</span>
        <span class="nx">nil</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">),</span> <span class="nx">cascadia</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">filterSelector</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// PrevMatcherUntilNodes is like PrevUntilNodes, with the</span>
<span class="c1">// option to filter the results based on a matcher. It returns a new</span>
<span class="c1">// Selection object containing the matched elements.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">)</span> <span class="nx">PrevMatcherUntilNodes</span><span class="p">(</span><span class="nx">filter</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">nodes</span> <span class="p">...</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Nodes</span><span class="p">,</span> <span class="nx">siblingPrevUntil</span><span class="p">,</span>
        <span class="nx">nil</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">),</span> <span class="nx">filter</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Filter and push filters the nodes based on a matcher, and pushes the results</span>
<span class="c1">// on the stack, with the srcSel as previous selection.</span>
<span class="nx">func</span> <span class="nx">filterAndPush</span><span class="p">(</span><span class="nx">srcSel</span> <span class="o">*</span><span class="nx">Selection</span><span class="p">,</span> <span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="o">*</span><span class="nx">Selection</span> <span class="p">{</span>
    <span class="c1">// Create a temporary Selection with the specified nodes to filter using winnow</span>
    <span class="nx">sel</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Selection</span><span class="p">{</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">srcSel</span><span class="p">.</span><span class="nb">document</span><span class="p">,</span> <span class="nx">nil</span><span class="p">}</span>
    <span class="c1">// Filter based on matcher and push on stack</span>
    <span class="k">return</span> <span class="nx">pushStack</span><span class="p">(</span><span class="nx">srcSel</span><span class="p">,</span> <span class="nx">winnow</span><span class="p">(</span><span class="nx">sel</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Internal implementation of Find that return raw nodes.</span>
<span class="nx">func</span> <span class="nx">findWithMatcher</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">Matcher</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
    <span class="c1">// Map nodes to find the matches within the children of each node</span>
    <span class="k">return</span> <span class="nx">mapNodes</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">func</span><span class="p">(</span><span class="nx">i</span> <span class="kr">int</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Go down one level, becausejQuery&#39;s Find selects only within descendants</span>
        <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
                <span class="nx">result</span> <span class="o">=</span> <span class="nx">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">MatchAll</span><span class="p">(</span><span class="nx">c</span><span class="p">)...)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Internal implementation to get all parent nodes, stopping at the specified</span>
<span class="c1">// node (or nil if no stop).</span>
<span class="nx">func</span> <span class="nx">getParentsNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">stopm</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">stopNodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">mapNodes</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">func</span><span class="p">(</span><span class="nx">i</span> <span class="kr">int</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span><span class="p">;</span> <span class="nx">p</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Parent</span> <span class="p">{</span>
            <span class="nx">sel</span> <span class="o">:=</span> <span class="nx">newSingleSelection</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">nil</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">stopm</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">sel</span><span class="p">.</span><span class="nx">IsMatcher</span><span class="p">(</span><span class="nx">stopm</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">len</span><span class="p">(</span><span class="nx">stopNodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">sel</span><span class="p">.</span><span class="nx">IsNodes</span><span class="p">(</span><span class="nx">stopNodes</span><span class="p">...)</span> <span class="p">{</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
                <span class="nx">result</span> <span class="o">=</span> <span class="nx">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Internal implementation of sibling nodes that return a raw slice of matches.</span>
<span class="nx">func</span> <span class="nx">getSiblingNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">siblingType</span><span class="p">,</span> <span class="nx">untilm</span> <span class="nx">Matcher</span><span class="p">,</span> <span class="nx">untilNodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">f</span> <span class="nx">func</span><span class="p">(</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span>

    <span class="c1">// If the requested siblings are ...Until, create the test function to</span>
    <span class="c1">// determine if the until condition is reached (returns true if it is)</span>
    <span class="k">if</span> <span class="nx">st</span> <span class="o">==</span> <span class="nx">siblingNextUntil</span> <span class="o">||</span> <span class="nx">st</span> <span class="o">==</span> <span class="nx">siblingPrevUntil</span> <span class="p">{</span>
        <span class="nx">f</span> <span class="o">=</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">untilm</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
                <span class="c1">// Matcher-based condition</span>
                <span class="nx">sel</span> <span class="o">:=</span> <span class="nx">newSingleSelection</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">nil</span><span class="p">)</span>
                <span class="k">return</span> <span class="nx">sel</span><span class="p">.</span><span class="nx">IsMatcher</span><span class="p">(</span><span class="nx">untilm</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">len</span><span class="p">(</span><span class="nx">untilNodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// Nodes-based condition</span>
                <span class="nx">sel</span> <span class="o">:=</span> <span class="nx">newSingleSelection</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">nil</span><span class="p">)</span>
                <span class="k">return</span> <span class="nx">sel</span><span class="p">.</span><span class="nx">IsNodes</span><span class="p">(</span><span class="nx">untilNodes</span><span class="p">...)</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">mapNodes</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">func</span><span class="p">(</span><span class="nx">i</span> <span class="kr">int</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">getChildrenWithSiblingType</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span><span class="p">,</span> <span class="nx">st</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Gets the children nodes of each node in the specified slice of nodes,</span>
<span class="c1">// based on the sibling type request.</span>
<span class="nx">func</span> <span class="nx">getChildrenNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">siblingType</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">mapNodes</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">func</span><span class="p">(</span><span class="nx">i</span> <span class="kr">int</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">getChildrenWithSiblingType</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">st</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">nil</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Gets the children of the specified parent, based on the requested sibling</span>
<span class="c1">// type, skipping a specified node if required.</span>
<span class="nx">func</span> <span class="nx">getChildrenWithSiblingType</span><span class="p">(</span><span class="nx">parent</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">siblingType</span><span class="p">,</span> <span class="nx">skipNode</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span>
    <span class="nx">untilFunc</span> <span class="nx">func</span><span class="p">(</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// Create the iterator function</span>
    <span class="kd">var</span> <span class="nx">iter</span> <span class="o">=</span> <span class="nx">func</span><span class="p">(</span><span class="nx">cur</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Based on the sibling type requested, iterate the right way</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="nx">st</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nx">siblingAll</span><span class="p">,</span> <span class="nx">siblingAllIncludingNonElements</span><span class="o">:</span>
                <span class="k">if</span> <span class="nx">cur</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
                    <span class="c1">// First iteration, start with first child of parent</span>
                    <span class="c1">// Skip node if required</span>
                    <span class="k">if</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">ret</span> <span class="o">==</span> <span class="nx">skipNode</span> <span class="o">&amp;&amp;</span> <span class="nx">skipNode</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
                        <span class="nx">ret</span> <span class="o">=</span> <span class="nx">skipNode</span><span class="p">.</span><span class="nx">NextSibling</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// Skip node if required</span>
                    <span class="k">if</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">NextSibling</span><span class="p">;</span> <span class="nx">ret</span> <span class="o">==</span> <span class="nx">skipNode</span> <span class="o">&amp;&amp;</span> <span class="nx">skipNode</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
                        <span class="nx">ret</span> <span class="o">=</span> <span class="nx">skipNode</span><span class="p">.</span><span class="nx">NextSibling</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="k">case</span> <span class="nx">siblingPrev</span><span class="p">,</span> <span class="nx">siblingPrevAll</span><span class="p">,</span> <span class="nx">siblingPrevUntil</span><span class="o">:</span>
                <span class="k">if</span> <span class="nx">cur</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
                    <span class="c1">// Start with previous sibling of the skip node</span>
                    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">skipNode</span><span class="p">.</span><span class="nx">PrevSibling</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">PrevSibling</span>
                <span class="p">}</span>
            <span class="k">case</span> <span class="nx">siblingNext</span><span class="p">,</span> <span class="nx">siblingNextAll</span><span class="p">,</span> <span class="nx">siblingNextUntil</span><span class="o">:</span>
                <span class="k">if</span> <span class="nx">cur</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
                    <span class="c1">// Start with next sibling of the skip node</span>
                    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">skipNode</span><span class="p">.</span><span class="nx">NextSibling</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">NextSibling</span>
                <span class="p">}</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="nx">panic</span><span class="p">(</span><span class="s2">&quot;Invalid sibling type.&quot;</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">ret</span> <span class="o">==</span> <span class="nx">nil</span> <span class="o">||</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">||</span> <span class="nx">st</span> <span class="o">==</span> <span class="nx">siblingAllIncludingNonElements</span> <span class="p">{</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="c1">// Not a valid node, try again from this one</span>
            <span class="nx">cur</span> <span class="o">=</span> <span class="nx">ret</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">iter</span><span class="p">(</span><span class="nx">nil</span><span class="p">);</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">iter</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If this is an ...Until case, test before append (returns true</span>
        <span class="c1">// if the until condition is reached)</span>
        <span class="k">if</span> <span class="nx">st</span> <span class="o">==</span> <span class="nx">siblingNextUntil</span> <span class="o">||</span> <span class="nx">st</span> <span class="o">==</span> <span class="nx">siblingPrevUntil</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">untilFunc</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">result</span> <span class="o">=</span> <span class="nx">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">st</span> <span class="o">==</span> <span class="nx">siblingNext</span> <span class="o">||</span> <span class="nx">st</span> <span class="o">==</span> <span class="nx">siblingPrev</span> <span class="p">{</span>
            <span class="c1">// Only one node was requested (immediate next or previous), so exit</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Internal implementation of parent nodes that return a raw slice of Nodes.</span>
<span class="nx">func</span> <span class="nx">getParentNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">mapNodes</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">func</span><span class="p">(</span><span class="nx">i</span> <span class="kr">int</span><span class="p">,</span> <span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
            <span class="k">return</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">{</span><span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span><span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">nil</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// Internal map function used by many traversing methods. Takes the source nodes</span>
<span class="c1">// to iterate on and the mapping function that returns an array of nodes.</span>
<span class="c1">// Returns an array of nodes mapped by calling the callback function once for</span>
<span class="c1">// each node in the source nodes.</span>
<span class="nx">func</span> <span class="nx">mapNodes</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">f</span> <span class="nx">func</span><span class="p">(</span><span class="kr">int</span><span class="p">,</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">nodes</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">vals</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span> <span class="nx">len</span><span class="p">(</span><span class="nx">vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">result</span> <span class="o">=</span> <span class="nx">appendWithoutDuplicates</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">vals</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>
</pre></div>


<h2><strong>2 cascadia</strong></h2>
<h3><strong>1.3 Code Analysis</strong><span id="1.3"></span></h3>
<h4><strong>1.3.1 selector.go &amp; selector_test.go</strong><span id="1.3.1"></span></h4>
<div class="highlight"><pre><span class="c1">// A Selector is a function which tells whether a node matches or not.</span>
<span class="nx">type</span> <span class="nx">Selector</span> <span class="nx">func</span><span class="p">(</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span>

<span class="c1">// hasChildMatch returns whether n has any child that matches a.</span>
<span class="nx">func</span> <span class="nx">hasChildMatch</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">a</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// hasDescendantMatch performs a depth-first search of n&#39;s descendants,</span>
<span class="c1">// testing whether any of them match a. It returns true as soon as a match is</span>
<span class="c1">// found, or false if no match is found.</span>
<span class="nx">func</span> <span class="nx">hasDescendantMatch</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">a</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">hasDescendantMatch</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">a</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// Compile parses a selector and returns, if successful, a Selector object</span>
<span class="c1">// that can be used to match against html.Node objects.</span>
<span class="nx">func</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">sel</span> <span class="nx">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Selector</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">parser</span><span class="p">{</span><span class="nx">s</span><span class="o">:</span> <span class="nx">sel</span><span class="p">}</span>
    <span class="nx">compiled</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">parseSelectorGroup</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">(</span><span class="nx">sel</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Errorf</span><span class="p">(</span><span class="s2">&quot;parsing %q: %d bytes left over&quot;</span><span class="p">,</span> <span class="nx">sel</span><span class="p">,</span> <span class="nx">len</span><span class="p">(</span><span class="nx">sel</span><span class="p">)</span><span class="o">-</span><span class="nx">p</span><span class="p">.</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">compiled</span><span class="p">,</span> <span class="nx">nil</span>
<span class="p">}</span>

<span class="c1">// MustCompile is like Compile, but panics instead of returning an error.</span>
<span class="nx">func</span> <span class="nx">MustCompile</span><span class="p">(</span><span class="nx">sel</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="nx">compiled</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">sel</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="nx">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">compiled</span>
<span class="p">}</span>

<span class="c1">// MatchAll returns a slice of the nodes that match the selector,</span>
<span class="c1">// from n and its children.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">MatchAll</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">matchAllInto</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">matchAllInto</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">storage</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">storage</span> <span class="o">=</span> <span class="nx">append</span><span class="p">(</span><span class="nx">storage</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">child</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">child</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
        <span class="nx">storage</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">matchAllInto</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">storage</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">storage</span>
<span class="p">}</span>

<span class="c1">// Match returns true if the node matches the selector.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">Match</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// MatchFirst returns the first node that matches s, from n and its children.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">MatchFirst</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Match</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">n</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
        <span class="nx">m</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">MatchFirst</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">m</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">m</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">nil</span>
<span class="p">}</span>

<span class="c1">// Filter returns the nodes in nodes that match the selector.</span>
<span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">Filter</span><span class="p">(</span><span class="nx">nodes</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="cp">[]</span><span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">nodes</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">s</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">result</span> <span class="o">=</span> <span class="nx">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// typeSelector returns a Selector that matches elements with a given tag name.</span>
<span class="nx">func</span> <span class="nx">typeSelector</span><span class="p">(</span><span class="nx">tag</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="nx">tag</span> <span class="o">=</span> <span class="nx">toLowerASCII</span><span class="p">(</span><span class="nx">tag</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="nx">tag</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// toLowerASCII returns s with all ASCII capital letters lowercased.</span>
<span class="nx">func</span> <span class="nx">toLowerASCII</span><span class="p">(</span><span class="nx">s</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="cp">[]</span><span class="kr">byte</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">s</span><span class="cp">[</span><span class="nx">i</span><span class="cp">]</span><span class="p">;</span> <span class="s1">&#39;A&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="s1">&#39;Z&#39;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
                <span class="nx">b</span> <span class="o">=</span> <span class="nx">make</span><span class="p">(</span><span class="cp">[]</span><span class="kr">byte</span><span class="p">,</span> <span class="nx">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
                <span class="nx">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">b</span><span class="cp">[</span><span class="nx">i</span><span class="cp">]</span> <span class="o">=</span> <span class="nx">s</span><span class="cp">[</span><span class="nx">i</span><span class="cp">]</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span> <span class="o">-</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">s</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// attributeSelector returns a Selector that matches elements</span>
<span class="c1">// where the attribute named key satisifes the function f.</span>
<span class="nx">func</span> <span class="nx">attributeSelector</span><span class="p">(</span><span class="nx">key</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">f</span> <span class="nx">func</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="nx">bool</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="nx">key</span> <span class="o">=</span> <span class="nx">toLowerASCII</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">!=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="nx">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Attr</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Key</span> <span class="o">==</span> <span class="nx">key</span> <span class="o">&amp;&amp;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// attributeExistsSelector returns a Selector that matches elements that have</span>
<span class="c1">// an attribute named key.</span>
<span class="nx">func</span> <span class="nx">attributeExistsSelector</span><span class="p">(</span><span class="nx">key</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">attributeSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">func</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// attributeEqualsSelector returns a Selector that matches elements where</span>
<span class="c1">// the attribute named key has the value val.</span>
<span class="nx">func</span> <span class="nx">attributeEqualsSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">attributeSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span>
        <span class="nx">func</span><span class="p">(</span><span class="nx">s</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">val</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// attributeIncludesSelector returns a Selector that matches elements where</span>
<span class="c1">// the attribute named key is a whitespace-separated list that includes val.</span>
<span class="nx">func</span> <span class="nx">attributeIncludesSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">attributeSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span>
        <span class="nx">func</span><span class="p">(</span><span class="nx">s</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
            <span class="k">for</span> <span class="nx">s</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="p">{</span>
                <span class="nx">i</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">IndexAny</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s2">&quot; \t\r\n\f&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">val</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="nx">s</span><span class="cp">[</span><span class="p">:</span><span class="nx">i</span><span class="cp">]</span> <span class="o">==</span> <span class="nx">val</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="kc">true</span>
                <span class="p">}</span>
                <span class="nx">s</span> <span class="o">=</span> <span class="nx">s</span><span class="cp">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="cp">]</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// attributeDashmatchSelector returns a Selector that matches elements where</span>
<span class="c1">// the attribute named key equals val or starts with val plus a hyphen.</span>
<span class="nx">func</span> <span class="nx">attributeDashmatchSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">attributeSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span>
        <span class="nx">func</span><span class="p">(</span><span class="nx">s</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">val</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nx">len</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">false</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">s</span><span class="cp">[</span><span class="p">:</span><span class="nx">len</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span><span class="cp">]</span> <span class="o">==</span> <span class="nx">val</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="cp">[</span><span class="nx">len</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span><span class="cp">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// attributePrefixSelector returns a Selector that matches elements where</span>
<span class="c1">// the attribute named key starts with val.</span>
<span class="nx">func</span> <span class="nx">attributePrefixSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">attributeSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span>
        <span class="nx">func</span><span class="p">(</span><span class="nx">s</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">HasPrefix</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// attributeSuffixSelector returns a Selector that matches elements where</span>
<span class="c1">// the attribute named key ends with val.</span>
<span class="nx">func</span> <span class="nx">attributeSuffixSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">attributeSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span>
        <span class="nx">func</span><span class="p">(</span><span class="nx">s</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">HasSuffix</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// attributeSubstringSelector returns a Selector that matches nodes where</span>
<span class="c1">// the attribute named key contains val.</span>
<span class="nx">func</span> <span class="nx">attributeSubstringSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">attributeSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span>
        <span class="nx">func</span><span class="p">(</span><span class="nx">s</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// attributeRegexSelector returns a Selector that matches nodes where</span>
<span class="c1">// the attribute named key matches the regular expression rx</span>
<span class="nx">func</span> <span class="nx">attributeRegexSelector</span><span class="p">(</span><span class="nx">key</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">rx</span> <span class="o">*</span><span class="nx">regexp</span><span class="p">.</span><span class="nx">Regexp</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">attributeSelector</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span>
        <span class="nx">func</span><span class="p">(</span><span class="nx">s</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">rx</span><span class="p">.</span><span class="nx">MatchString</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="c1">// intersectionSelector returns a selector that matches nodes that match</span>
<span class="c1">// both a and b.</span>
<span class="nx">func</span> <span class="nx">intersectionSelector</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// unionSelector returns a selector that matches elements that match</span>
<span class="c1">// either a or b.</span>
<span class="nx">func</span> <span class="nx">unionSelector</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">||</span> <span class="nx">b</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// negatedSelector returns a selector that matches elements that do not match a.</span>
<span class="nx">func</span> <span class="nx">negatedSelector</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">!=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">!</span><span class="nx">a</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// writeNodeText writes the text contained in n and its descendants to b.</span>
<span class="nx">func</span> <span class="nx">writeNodeText</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">b</span> <span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">html</span><span class="p">.</span><span class="nx">TextNode</span><span class="o">:</span>
        <span class="nx">b</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span><span class="o">:</span>
        <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
            <span class="nx">writeNodeText</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// nodeText returns the text contained in n and its descendants.</span>
<span class="nx">func</span> <span class="nx">nodeText</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="nx">writeNodeText</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nb">String</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// nodeOwnText returns the contents of the text nodes that are direct</span>
<span class="c1">// children of n.</span>
<span class="nx">func</span> <span class="nx">nodeOwnText</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
    <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">TextNode</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nb">String</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// textSubstrSelector returns a selector that matches nodes that</span>
<span class="c1">// contain the given text.</span>
<span class="nx">func</span> <span class="nx">textSubstrSelector</span><span class="p">(</span><span class="nx">val</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="nx">text</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">nodeText</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ownTextSubstrSelector returns a selector that matches nodes that</span>
<span class="c1">// directly contain the given text</span>
<span class="nx">func</span> <span class="nx">ownTextSubstrSelector</span><span class="p">(</span><span class="nx">val</span> <span class="nx">string</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="nx">text</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">nodeOwnText</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
        <span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// textRegexSelector returns a selector that matches nodes whose text matches</span>
<span class="c1">// the specified regular expression</span>
<span class="nx">func</span> <span class="nx">textRegexSelector</span><span class="p">(</span><span class="nx">rx</span> <span class="o">*</span><span class="nx">regexp</span><span class="p">.</span><span class="nx">Regexp</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">rx</span><span class="p">.</span><span class="nx">MatchString</span><span class="p">(</span><span class="nx">nodeText</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ownTextRegexSelector returns a selector that matches nodes whose text</span>
<span class="c1">// directly matches the specified regular expression</span>
<span class="nx">func</span> <span class="nx">ownTextRegexSelector</span><span class="p">(</span><span class="nx">rx</span> <span class="o">*</span><span class="nx">regexp</span><span class="p">.</span><span class="nx">Regexp</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">rx</span><span class="p">.</span><span class="nx">MatchString</span><span class="p">(</span><span class="nx">nodeOwnText</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// hasChildSelector returns a selector that matches elements</span>
<span class="c1">// with a child that matches a.</span>
<span class="nx">func</span> <span class="nx">hasChildSelector</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">!=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">hasChildMatch</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// hasDescendantSelector returns a selector that matches elements</span>
<span class="c1">// with any descendant that matches a.</span>
<span class="nx">func</span> <span class="nx">hasDescendantSelector</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">!=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">hasDescendantMatch</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// nthChildSelector returns a selector that implements :nth-child(an+b).</span>
<span class="c1">// If last is true, implements :nth-last-child instead.</span>
<span class="c1">// If ofType is true, implements :nth-of-type instead.</span>
<span class="nx">func</span> <span class="nx">nthChildSelector</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kr">int</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">ofType</span> <span class="nx">bool</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">!=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>

        <span class="nx">parent</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span>
        <span class="k">if</span> <span class="nx">parent</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>

        <span class="nx">i</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Type</span> <span class="o">!=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">ofType</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Data</span> <span class="o">!=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            <span class="nx">count</span><span class="o">++</span>
            <span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
                <span class="nx">i</span> <span class="o">=</span> <span class="nx">count</span>
                <span class="k">if</span> <span class="o">!</span><span class="nx">last</span> <span class="p">{</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
            <span class="c1">// This shouldn&#39;t happen, since n should always be one of its parent&#39;s children.</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">last</span> <span class="p">{</span>
            <span class="nx">i</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">-</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">}</span>

        <span class="nx">i</span> <span class="o">-=</span> <span class="nx">b</span>
        <span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">i</span><span class="o">%</span><span class="nx">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span><span class="o">/</span><span class="nx">a</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// onlyChildSelector returns a selector that implements :only-child.</span>
<span class="c1">// If ofType is true, it implements :only-of-type instead.</span>
<span class="nx">func</span> <span class="nx">onlyChildSelector</span><span class="p">(</span><span class="nx">ofType</span> <span class="nx">bool</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">!=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>

        <span class="nx">parent</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span>
        <span class="k">if</span> <span class="nx">parent</span> <span class="o">==</span> <span class="nx">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>

        <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Type</span> <span class="o">!=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">ofType</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Data</span> <span class="o">!=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            <span class="nx">count</span><span class="o">++</span>
            <span class="k">if</span> <span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">count</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// inputSelector is a Selector that matches input, select, textarea and button elements.</span>
<span class="nx">func</span> <span class="nx">inputSelector</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s2">&quot;input&quot;</span> <span class="o">||</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s2">&quot;select&quot;</span> <span class="o">||</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s2">&quot;textarea&quot;</span> <span class="o">||</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Data</span> <span class="o">==</span> <span class="s2">&quot;button&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// emptyElementSelector is a Selector that matches empty elements.</span>
<span class="nx">func</span> <span class="nx">emptyElementSelector</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">!=</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">FirstChild</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">NextSibling</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">html</span><span class="p">.</span><span class="nx">ElementNode</span><span class="p">,</span> <span class="nx">html</span><span class="p">.</span><span class="nx">TextNode</span><span class="o">:</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// descendantSelector returns a Selector that matches an element if</span>
<span class="c1">// it matches d and has an ancestor that matches a.</span>
<span class="nx">func</span> <span class="nx">descendantSelector</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nx">d</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span><span class="p">;</span> <span class="nx">p</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Parent</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">a</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// childSelector returns a Selector that matches an element if</span>
<span class="c1">// it matches d and its parent matches a.</span>
<span class="nx">func</span> <span class="nx">childSelector</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">Selector</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">d</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">a</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Parent</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// siblingSelector returns a Selector that matches an element</span>
<span class="c1">// if it matches s2 and in is preceded by an element that matches s1.</span>
<span class="c1">// If adjacent is true, the sibling must be immediately before the element.</span>
<span class="nx">func</span> <span class="nx">siblingSelector</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span> <span class="nx">Selector</span><span class="p">,</span> <span class="nx">adjacent</span> <span class="nx">bool</span><span class="p">)</span> <span class="nx">Selector</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">html</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="nx">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nx">s2</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">adjacent</span> <span class="p">{</span>
            <span class="k">for</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">PrevSibling</span><span class="p">;</span> <span class="nx">n</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">PrevSibling</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">TextNode</span> <span class="o">||</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">html</span><span class="p">.</span><span class="nx">CommentNode</span> <span class="p">{</span>
                    <span class="k">continue</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="nx">s1</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>

        <span class="c1">// Walk backwards looking for element that matches s1</span>
        <span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">PrevSibling</span><span class="p">;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="nx">nil</span><span class="p">;</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">PrevSibling</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">s1</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
            
            <section>
<div class="accordion" id="accordion2">
    <div class="accordion-group">
        <div class="accordion-heading">
            <a class="accordion-toggle disqus-comment-count" data-toggle="collapse" data-parent="#accordion2"
                href="http://aleda.cn/article/2015/12/goquery/#disqus_thread">
                Comments
            </a>
        </div>
        <div id="disqus_thread" class="accordion-body collapse">
            <div class="accordion-inner">
                <div class="comments">
                    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'aleda';
        var disqus_identifier = 'http://aleda.cn/article/2015/12/goquery/';
    var disqus_url = 'http://aleda.cn/article/2015/12/goquery/';

    (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

                </div>
            </div>
        </div>
    </div>
</div>
</section>

            <hr/>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2015-12-29T14:39:00+08:00">Dec 29, 2015</time>
            <h4>Category</h4>
            <a class="category-link" href="http://aleda.cn/categories.html#code-reading-ref">code-reading</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="http://aleda.cn/tags.html#code-reading-ref">code-reading
                    <span>9</span>
</a></li>
                <li><a href="http://aleda.cn/tags.html#experience-ref">experience
                    <span>13</span>
</a></li>
            </ul>
<h4>Contact</h4>
    <a href="http://github.com/Aleda" title="My Github Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-github sidebar-social-links"></i></a>
    <a href="mailto:aledalee@foxmail.com" title="My Email Address" class="sidebar-social-links" target="_blank">
    <i class="fa fa-envelope sidebar-social-links"></i></a>
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

            <script type="text/javascript">
var disqus_shortname = 'aleda';
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
<script  language="javascript" type="text/javascript">
function uncollapse() {
    if (window.location.hash.match(/^#comment-\d+$/)) {
        $('#disqus_thread').collapse('show');
    }
}
</script>
<script type="text/javascript" language="JavaScript">
uncollapse();
window.onhashchange=function(){
    if (window.location.hash.match(/^#comment-\d+$/))
        window.location.reload(true);
}
</script>
<script>
$('#disqus_thread').on('shown', function () {
    var link = document.getElementsByClassName('accordion-toggle');
    var old_innerHTML = link[0].innerHTML;
    $(link[0]).fadeOut(500, function() {
        $(this).text('Click here to hide comments').fadeIn(500);
    });
    $('#disqus_thread').on('hidden', function () {
        $(link[0]).fadeOut(500, function() {
            $(this).text(old_innerHTML).fadeIn(500);
        });
    })
})
</script>


    </body>
    <!-- Theme: Elegant built for Pelican
    License : http://oncrashreboot.com/pelican-elegant -->
</html>